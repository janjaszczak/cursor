---
description: Enforce SOLID during generation, review, and refactors
globs:
  - "**/*.{ts,tsx,js,jsx}"
  - "**/*.py"
  - "**/*.{env,yml,md}"
alwaysApply: false
---
General
- Prefer composition over inheritance unless full substitutability is guaranteed.
- Keep classes/modules small; question rapid growth in size/responsibilities.
- Dependencies explicit (ctor/params). Avoid `new` in business logic; use DI/factories.
- Return complete, runnable files and tests proving the contract.

Single Responsibility (SRP)
- One reason to change per class/module; separate logging/validation/error handling.
- Methods do one thing; if description needs “and/or”, split it.

Open/Closed (OCP)
- Extend via interfaces/abstracts, strategy/decorator. Replace type-based switches with polymorphism.

Liskov (LSP)
- Subtypes keep invariants; don’t tighten preconditions/loosen postconditions. No noop/throw overrides.

Interface Segregation (ISP)
- Minimal, client-specific interfaces; split “fat” ones; compose small role interfaces.

Dependency Inversion (DIP)
- High-level depends on abstractions. Define interfaces near clients; keep impls separate.

What to return in PRs
- Code + unit tests; show extension via interfaces/strategy (no edits to stable logic).
- Short rationale: SRP fit, chosen pattern, how OCP/LSP/ISP/DIP are satisfied.
